/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

#ifndef Compton_1step_h
#define Compton_1step_h

#include <RooAbsPdf.h>
#include <RooRealProxy.h>
#include <RooCategoryProxy.h>
#include <RooAbsReal.h>
#include <RooAbsCategory.h>

#include <complex>

class Compton_1step : public RooAbsPdf {
public:
   Compton_1step() {}
   Compton_1step(const char *name, const char *title,        RooAbsReal& _x,
        RooAbsReal& _resolution,
        RooAbsReal& _center1,
        RooAbsReal& _k,
        RooAbsReal& _base);
  Compton_1step(Compton_1step const &other, const char *name=nullptr);
  TObject* clone(const char *newname) const override { return new Compton_1step(*this, newname); }

   int getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char *rangeName=nullptr) const override;
   double analyticalIntegral(int code, const char *rangeName=nullptr) const override;
protected:

  RooRealProxy x ;
  RooRealProxy resolution ;
  RooRealProxy center1 ;
  RooRealProxy k ;
  RooRealProxy base ;

  double evaluate() const override;
  void doEval(RooFit::EvalContext &) const override;
  void translate(RooFit::Detail::CodeSquashContext &ctx) const override;

private:

  ClassDefOverride(Compton_1step, 1) // Your description goes here...
};
inline double Compton_1step_evaluate(double x, double resolution, double center1, double k, double base) 
{
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE

   return k*(1.+erf((x-center1)/(sqrt(2.)*resolution)))/2.+base; 
}


#endif // Compton_1step_h