/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Compton_1step.h"

#include <RooAbsReal.h>
#include <RooAbsCategory.h>

#include <Riostream.h>
#include <TMath.h>

#include <cmath>

ClassImp(Compton_1step);

Compton_1step::Compton_1step(const char *name, const char *title,
                        RooAbsReal& _x,
                        RooAbsReal& _resolution,
                        RooAbsReal& _center1,
                        RooAbsReal& _k,
                        RooAbsReal& _base)
   : RooAbsPdf(name,title),
   x("x","x",this,_x),
   resolution("resolution","resolution",this,_resolution),
   center1("center1","center1",this,_center1),
   k("k","k",this,_k),
   base("base","base",this,_base)
{
}

Compton_1step::Compton_1step(Compton_1step const &other, const char *name)
   : RooAbsPdf(other,name),
   x("x",this,other.x),
   resolution("resolution",this,other.resolution),
   center1("center1",this,other.center1),
   k("k",this,other.k),
   base("base",this,other.base)
{
}


double Compton_1step::evaluate() const 
{
   return Compton_1step_evaluate(x, resolution, center1, k, base); 
}

void Compton_1step::doEval(RooFit::EvalContext &ctx) const 
{ 
   std::span<const double> xSpan = ctx.at(x);
   std::span<const double> resolutionSpan = ctx.at(resolution);
   std::span<const double> center1Span = ctx.at(center1);
   std::span<const double> kSpan = ctx.at(k);
   std::span<const double> baseSpan = ctx.at(base);

   std::size_t n = ctx.output().size();
   for (std::size_t i = 0; i < n; ++i) {
      ctx.output()[i] = Compton_1step_evaluate(xSpan.size() > 1 ? xSpan[i] : xSpan[0],
                               resolutionSpan.size() > 1 ? resolutionSpan[i] : resolutionSpan[0],
                               center1Span.size() > 1 ? center1Span[i] : center1Span[0],
                               kSpan.size() > 1 ? kSpan[i] : kSpan[0],
                               baseSpan.size() > 1 ? baseSpan[i] : baseSpan[0]);
   }
} 
void Compton_1step::translate(RooFit::Detail::CodeSquashContext &ctx) const
{
   ctx.addResult(this, ctx.buildCall("Compton_1step_evaluate", x, resolution, center1, k, base));
}

int Compton_1step::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char */*rangeName*/) const
{
   // Support also using the imaginary unit
   using namespace std::complex_literals;
   // To be able to also comile C code, we define a variable that behaves like the "I" macro from C.
   constexpr auto I = 1i;

   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS. THE EXAMPLE
   // BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X YOU CAN ALSO
   // IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs
   // EXPRESSION MULTIPLE TIMES.
   if (matchArgs(allVars,analVars,x)) return 1 ; 
   return 0 ; 
} 


double Compton_1step::analyticalIntegral(int code, const char *rangeName) const
{
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY
  // getAnalyticalIntegral(). THE MEMBER FUNCTION x.min(rangeName) AND
  // x.max(rangeName) WILL RETURN THE INTEGRATION BOUNDARIES FOR EACH
  // OBSERVABLE x.
   if (code==1) { return ((k*1/2.*((x.max(rangeName)-center1)*erf((x.max(rangeName)-center1)/(sqrt(2.)*resolution))+sqrt(2./TMath::Pi())*resolution*TMath::Gaus(x.max(rangeName),center1,resolution)+x.max(rangeName))+base*x.max(rangeName))-(k*1/2.*((x.min(rangeName)-center1)*erf((x.min(rangeName)-center1)/(sqrt(2.)*resolution))+sqrt(2./TMath::Pi())*resolution*TMath::Gaus(x.min(rangeName),center1,resolution)+x.min(rangeName))+base*x.min(rangeName))) ; } 
   return 0 ; 
} 
